<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[jwage.com]]></title>
    <link href="https://jwage.com/blog/categories/articles.xml" rel="self"/>
    <link href="https://jwage.com/"/>
    <updated>2018-03-25T02:13:30-04:00</updated>
    <id>https://jwage.com/</id>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[Using the Symfony Expression Language for a Reward Rules Engine]]></title>
            <link href="https://jwage.com/posts/2014/02/15/using-the-symfony-expression-language-for-a-reward"/>
            <updated>2014-02-15T00:00:00-05:00</updated>
            <id>https://jwage.com/posts/2014/02/15/using-the-symfony-expression-language-for-a-reward</id>
            <content type="html"><![CDATA[<p>We recently adopted the <a href="http://symfony.com/doc/current/components/expression_language/index.html" target="_blank">Symfony Expression Language</a> in the rules engine at <a href="http://www.opensky.com" target="_blank">OpenSky</a>. It has brought a new level of flexibility to our system and creating new logic has never been easier.</p>

<p>Installing the expression language in your application is easy with composer. Just add the following to your <code>composer.json</code>:</p>

<pre><code>"symfony/expression-language": "2.5.*@dev"
</code></pre>

<p>The expression language allows you to perform expressions that get evaluated with raw PHP code and return a single value. It can be any type of value and is not limited to boolean values. Here is a simple example:</p>

<pre><code>use Symfony\Component\ExpressionLanguage\ExpressionLanguage;

$language = new ExpressionLanguage();

$expression = 'user["isActive"] == true and product["price"] &gt; 20';
$context = array(
    'user' =&gt; array(
        'isActive' =&gt; true
    ),
    'product' =&gt; array(
        'price' =&gt; 30
    ),
);

$return = $language-&gt;evaluate($expression, $context);

var_export($return); // true
</code></pre>

<p>That is a very simple example on how to use the raw expression language. Now I will try to demonstrate how you could model a real implementation using <a href="http://www.doctrine-project.org" target="_blank">Doctrine</a> to persist your rules to a database, the <a href="http://symfony.com/doc/current/components/event_dispatcher/introduction.html" target="_blank">Symfony Event Dispatcher</a> to evaluate your rules and execute actions when your expressions evaluate to true.</p>

<p>To get started create a new <code>Rule</code> class and map it to a database using one of the Doctrine object mappers. For this example we will map it using the MongoDB ODM:</p>

<pre><code>use Doctrine\ODM\MongoDB\Mapping\Annotations as ODM;

/**
 * @ODM\Document
 */
class Rule
{
    /**
     * @ODM\Id
     */
    private $id;

    /**
     * @ODM\Collection
     */
    private $eventNames = array();

    /**
     * @ODM\String
     */
    private $expression;

    /**
     * @ODM\Collection
     */
    private $actionEvents = array();

    // ...
}
</code></pre>

<p>Now imagine you already have an event named <code>user.add_to_cart</code> being notified in your application. It looks something like this:</p>

<pre><code>use Symfony\Component\EventDispatcher\Event;

class UserAddToCartEvent extends Event
{
    const onUserAddToCart = 'user.add_to_cart';

    private $user;
    private $product;

    // ...
}

class AddToCartController
{
    // ...

    public function addToCartAction($productId)
    {
        // ...

        $this-&gt;dispatcher-&gt;dispatch(UserAddToCartEvent::onUserAddToCart, new UserAddToCartEvent($user, $product));
    }
}
</code></pre>

<p>Say you want to give a reward to users who add items to their cart when they have loved more than <code>20</code> items and the price of the product is greater than <code>50</code> dollars. The <code>Rule</code> model we created earlier allows us to define a rule that will be executed when <code>UserAddToCart::onUserAddToCart</code> is dispatched:</p>

<pre><code>$rule = new Rule();

// set the events this rule should be executed on.
$rule-&gt;setEventNames(array(
    UserAddToCartEvent::onUserAddToCart
));

// set the expression to evaluate when the rule is executed.
// if the user has loved more than 20 items and the price of the product is more than 50 dollars.
// the expression string will be evaluated by the Symfony expression language.
$rule-&gt;setExpression('event.getUser().getNumLoves() &gt; 20 and event.getProduct().getPrice() &gt; 50');

// set the action events to dispatch when the expression evaluates to true.
$rule-&gt;setActionEvents(array(
    array(
        'eventName' =&gt; UserCreditRewardEvent::onUserCreditReward,
        'recipientExpression' =&gt; 'event.getUser()',
        'attributes' =&gt; array(
            'amount' =&gt; 50
        ),
    )
));

$dm-&gt;persist($rule);
$dm-&gt;flush();
</code></pre>

<p>The above example assumes you have a <code>UserCreditRewardEvent</code> setup and a listener setup to process the event to give the user a credit. Here is what the event would look like:</p>

<pre><code>use Symfony\Component\EventDispatcher\Event;

class UserCreditRewardEvent extends Event
{
    const onUserCreditReward = 'user.credit_reward';

    private $user;
    private $amount;

    // ...
}
</code></pre>

<p>And here is what the listener would look like to give the user the credit. This example assumes you already have a <code>CreditManager</code> service with an <code>issueCredit()</code> method you can use to give a user a credit for a dollar amount:</p>

<pre><code>class UserCreditRewardListener
{
    private $creditManager;

    // ...

    public function onUserCreditReward(UserCreditRewardEvent $event)
    {
        $this-&gt;creditManager-&gt;issueCredit(
            $event-&gt;getUser(),
            $event-&gt;getAmount()
        );
    }
}
</code></pre>

<p>Now to bring it all together we need a <code>RuleSubcriber</code> to lookup the <code>Rule</code> objects from the database when events occur in our application. This class will evaluate the rules and then dispatch the resulting action events when the expressions return true.</p>

<pre><code>use Symfony\Component\EventDispatcher\Event;
use Symfony\Component\EventDispatcher\EventSubscriberInterface;

class RuleSubcriber implements EventSubscriberInterface
{
    private $dm;
    private $expressionLanguage;
    private $actionEventFactory;

    // ...

    public static function getSubscribedEvents()
    {
        return array(
            UserAddToCartEvent::onUserAddToCart =&gt; array('handleEvent', 0),
        );
    }

    public function handleEvent(Event $event)
    {
        $rules = $this-&gt;findRulesByEventName($event-&gt;getName());

        foreach ($rules as $rule) {
            if ($this-&gt;evaluateRule($rule, $event)) {
                $this-&gt;dispatchActionEvents($rule, $event);
            }
        }
    }

    private function findRulesByEventName($eventName)
    {
        return $this-&gt;dm-&gt;createQueryBuilder()
            -&gt;field('eventNames')-&gt;equals($eventName)
            -&gt;getQuery()
            -&gt;execute();
    }

    private function evaluateRule(Rule $rule, Event $event)
    {
        return $this-&gt;expressionLanguage-&gt;evaluate($rule-&gt;getExpression(), array(
            'event' =&gt; $event,
        ));
    }

    private function dispatchActionEvents(Rule $rule, Event $event)
    {
        foreach ($rule-&gt;getActionEvents() as $action) {
            $this-&gt;dispatchActionEvent($action, $rule, $event);
        }
    }

    private function dispatchActionEvent(array $action, Rule $rule, Event $event)
    {
        $recipientUser = $this-&gt;expressionLanguage($action['recipientExpression'], array(
            'event' =&gt; $event,
        ));

        $actionEvent = $this-&gt;actionEventFactory-&gt;createActionEvent(
            $action,
            $recipientUser,
            $rule
        );

        $this-&gt;dispatcher-&gt;dispatch($action['eventName'], $actionEvent);
    }
}
</code></pre>

<p>The <code>ActionEventFactory</code> used in the above <code>RuleSubcriber</code> is a simple service used to create the action events we dispatch for our rules.</p>

<pre><code>class ActionEventFactory
{
    public function createActionEvent(array $action, User $user, Rule $rule)
    {
        switch ($action['eventName']) {
            // ...

            case UserCreditRewardEvent::onUserCreditReward:
                return new UserCreditRewardEvent($user, $action['attributes']['amount']);
        }
    }
}
</code></pre>

<p>That is it! Now you have the ability to define rules that can be created with a user interface in your application and stored in a database. These rules get evaluated when certain events are dispatched within your application. When those rules evaluate to true you can dispatch other events that can give out credits, give free shipping, send e-mails, or do anything you can possibly imagine. Build up a repository of common actions as events and allow your business people to define new rules and rewards for promotional campaigns without having to involve a software engineer.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Doctrine is not just an ORM for Relational Databases]]></title>
            <link href="https://jwage.com/posts/2014/01/18/doctrine-is-not-just-an-orm-for-relational"/>
            <updated>2014-01-18T00:00:00-05:00</updated>
            <id>https://jwage.com/posts/2014/01/18/doctrine-is-not-just-an-orm-for-relational</id>
            <content type="html"><![CDATA[<p>In April of 2010 the <a href="https://github.com/doctrine/mongodb-odm/commit/92582ffe5facffa4d2379f176dbee539918db962" target="_blank">first commit</a> for the Doctrine MongoDB ODM project was made. I was experimenting with MongoDB at the time and I wanted to see how difficult it would be to build a version of Doctrine for MongoDB.</p>

<p>Up until the MongoDB ODM, Doctrine was solely a project built around the DBAL/ORM and was advertised as such. In May of 2010 we decided to widen the scope of the project so that we could host libraries like the MongoDB ODM. This change led to a spur of new contributors and development and we now have several object mappers developed under Doctrine and things are more active than ever.</p>

<p>Below is an overview of all the libraries underneath the Doctrine project.</p>

<p><strong>Common Shared Libraries</strong></p>

<p><strong><a href="http://github.com/doctrine/common" target="_blank">doctrine/common</a></strong></p>

<p>Doctrine Common contains some base functionality and interfaces you need in order to create a Doctrine style object mapper. All of our mapper projects follow the same <code>Doctrine\Common\Persistence</code> interfaces. Here are the <code>ObjectManager</code> and <code>ObjectRepository</code> interfaces:</p>

<pre><code>&lt;?php

namespace Doctrine\Common\Persistence

interface ObjectManager
{
    public function find($className, $id);
    public function persist($object);
    public function remove($object);
    public function merge($object);
    public function clear($objectName = null);
    public function detach($object);
    public function refresh($object);
    public function flush();
    public function getRepository($className);
}

interface ObjectRepository
{
    public function find($id);
    public function findAll();
    public function findBy(array $criteria, array $orderBy = null, $limit = null, $offset = null);
    public function findOneBy(array $criteria);
}
</code></pre>

<p><strong><a href="http://github.com/doctrine/collections" target="_blank">doctrine/collections</a></strong></p>

<p>Doctrine Collections is a library that contains classes for working with arrays of data. Here is an example using the simple <code>Doctrine\Common\Collections\ArrayCollection</code> class:</p>

<pre><code>&lt;?php

$data = new \Doctrine\Common\Collections\ArrayCollection(array(1, 2, 3));
$data = $data-&gt;filter(function($count) { return $count &gt; 1; });
</code></pre>

<p><strong><a href="http://github.com/doctrine/annotations" target="_blank">doctrine/annotations</a></strong></p>

<p>Doctrine Annotations is a library that allows you to parse structured information out of a doc block.</p>

<p>Imagine you have a class with a doc block like the following:</p>

<pre><code>&lt;?php

/** @Foo(bar="value") */
class User
{

}
</code></pre>

<p>You can parse the information out of the doc block for <code>User</code> easily. Define a new annotation object:</p>

<pre><code>&lt;?php

/**
 * @Annotation
 * @Target("CLASS")
 */
class Foo
{
    /** @var string */
    public $bar;
}
</code></pre>

<p>Now you can get instances of <code>Foo</code> defined on the <code>User</code>:</p>

<pre><code>&lt;?php

$reflClass = new ReflectionClass('User');
$reader = new \Doctrine\Common\Annotations\AnnotationReader();
$classAnnotations = $reader-&gt;getClassAnnotations($reflClass);

foreach ($classAnnotations AS $annot) {
    if ($annot instanceof Foo) {
        echo $annot-&gt;bar; // prints "value";
    }
}
</code></pre>

<p><strong><a href="http://github.com/doctrine/inflector" target="_blank">doctrine/inflector</a></strong></p>

<p>Doctrine Inflector is a library that can perform string manipulations with regard to upper/lowercase and singular/plural forms of words.</p>

<pre><code>&lt;?php

$camelCase = 'camelCase';
$table = \Doctrine\Common\Inflector::tableize($camelCase);
echo $table; // camel_case
</code></pre>

<p><strong><a href="http://github.com/doctrine/lexer" target="_blank">doctrine/lexer</a></strong></p>

<p>Doctrine Lexer is a library that can be used in Top-Down, Recursive Descent Parsers. This lexer is used in Doctrine Annotations and in Doctrine ORM (DQL).</p>

<p>Here is what the <code>AbstractLexer</code> provided by Doctrine looks like:</p>

<pre><code>&lt;?php

namespace Doctrine\Common\Lexer;

abstract class AbstractLexer
{
    public function setInput($input);
    public function reset();
    public function resetPeek();
    public function resetPosition($position = 0);
    public function isNextToken($token);
    public function isNextTokenAny(array $tokens);
    public function moveNext();
    public function skipUntil($type);
    public function isA($value, $token);
    public function peek();
    public function glimpse();
    public function getLiteral($token);

    abstract protected function getCatchablePatterns();
    abstract protected function getNonCatchablePatterns();
    abstract protected function getType(&amp;$value);
}
</code></pre>

<p>To implement a lexer just extend the <code>Doctrine\Common\Lexer\AbstractParser</code> class and implement the <code>getCatchablePatterns</code>, <code>getNonCatchablePatterns</code>, and <code>getType</code> methods. Here is a very simple example lexer implementation named <code>CharacterTypeLexer</code>. It tokenizes a string to <code>T_UPPER</code>, <code>T_LOWER</code> and <code>T_NUMER</code>:</p>

<pre><code>&lt;?php

use Doctrine\Common\Lexer\AbstractParser;

class CharacterTypeLexer extends AbstractLexer
{
    const T_UPPER =  1;
    const T_LOWER =  2;
    const T_NUMBER = 3;

    protected function getCatchablePatterns()
    {
        return array(
            '[a-bA-Z0-9]',
        );
    }

    protected function getNonCatchablePatterns()
    {
        return array();
    }

    protected function getType(&amp;$value)
    {
        if (is_numeric($value)) {
            return self::T_NUMBER;
        }

        if (strtoupper($value) === $value) {
            return self::T_UPPER;
        }

        if (strtolower($value) === $value) {
            return self::T_LOWER;
        }
    }
}
</code></pre>

<p>Use <code>CharacterTypeLexer</code> to extract an array of upper case characters:</p>

<pre><code>&lt;?php

class UpperCaseCharacterExtracter
{
    private $lexer;

    public function __construct(CharacterTypeLexer $lexer)
    {
        $this-&gt;lexer = $lexer;
    }

    public function getUpperCaseCharacters($string)
    {
        $this-&gt;lexer-&gt;setInput($string);
        $this-&gt;lexer-&gt;moveNext();

        $upperCaseChars = array();
        while (true) {
            if (!$this-&gt;lexer-&gt;lookahead) {
                break;
            }

            $this-&gt;lexer-&gt;moveNext();

            if ($this-&gt;lexer-&gt;token['type'] === CharacterTypeLexer::T_UPPER) {
                $upperCaseChars[] = $this-&gt;lexer-&gt;token['value'];
            }
        }

        return $upperCaseChars;
    }
}

$upperCaseCharacterExtractor = new UpperCaseCharacterExtracter(new CharacterTypeLexer());
$upperCaseCharacters = $upperCaseCharacterExtractor-&gt;getUpperCaseCharacters('1aBcdEfgHiJ12');

print_r($upperCaseCharacters);
</code></pre>

<p>The variable <code>$upperCaseCharacters</code> contains all of the upper case characters:</p>

<pre><code>Array
(
    [0] =&gt; B
    [1] =&gt; E
    [2] =&gt; H
    [3] =&gt; J
)
</code></pre>

<p><strong><a href="http://github.com/doctrine/cache" target="_blank">doctrine/cache</a></strong></p>

<p>Doctrine Cache is a library that provides an interface for caching data. It comes with implementations for some of the most popular caching data stores. Here is what the <code>Cache</code> interface looks like:</p>

<pre><code>&lt;?php

namespace Doctrine\Common\Cache;

interface Cache
{
    function fetch($id);
    function contains($id);
    function save($id, $data, $lifeTime = 0);
    function delete($id);
    function getStats();
}
</code></pre>

<p>Here is an example using memcache:</p>

<pre><code>&lt;?php

$memcache = new \Memcache();
$cache = new \Doctrine\Common\Cache\MemcacheCache();
$cache-&gt;setMemcache($memcache);

$cache-&gt;set('key', 'value');

echo $cache-&gt;get('key') // prints "value"
</code></pre>

<p>Other supported drivers are:</p>

<ul><li>APC</li>
<li>Couchbase</li>
<li>Filesystem</li>
<li>Memcached</li>
<li>MongoDB</li>
<li>PhpFile</li>
<li>Redis</li>
<li>Riak</li>
<li>WinCache</li>
<li>Xcache</li>
<li>ZendData</li>
</ul>

<p><strong>Database Abstraction Layers</strong></p>

<p><strong><a href="http://github.com/doctrine/dbal" target="_blank">doctrine/dbal</a></strong></p>

<p>Doctrine DBAL is a library that provides an abstraction layer for relational databases in PHP. Read <a href="http://jwage.com/post/31080076112/doctrine-dbal-php-database-abstraction-layer" target="_blank">Doctrine DBAL: PHP Database Abstraction Layer</a> blog post for more information on the DBAL.</p>

<p><strong><a href="http://github.com/doctrine/mongodb" target="_blank">doctrine/mongodb</a></strong></p>

<p>Doctrine MongoDB is a library that provides an abstraction layer on top of the PHP MongoDB PECL extension. It provides some additional functionality and abstractions to make working with MongoDB easier.</p>

<p><strong><a href="http://github.com/doctrine/couchdb-client" target="_blank">doctrine/couchdb-client</a></strong></p>

<p>Doctrine CouchDB Client is a library that provides a connection abstraction to CouchDB by wrapping around the CouchDB HTTP API.</p>

<pre><code>&lt;?php

$client = \Doctrine\CouchDB\CouchDBClient::create();

array($id, $rev) = $client-&gt;postDocument(array('foo' =&gt; 'bar'));
$client-&gt;putDocument(array('foo' =&gt; 'baz'), $id, $rev);

$doc = $client-&gt;findDocument($id);
</code></pre>

<p><strong>Object Mappers</strong></p>

<p>The object mappers are where all the pieces come together. The object mappers provide transparent persistence for PHP objects. As mentioned above, they all implement the common interfaces from <code>Doctrine\Common</code> so working with each of them is generally the same. You have an <code>ObjectManager</code> to manage the persistent state of your domain objects:</p>

<pre><code>&lt;?php

$user = new User();
$user-&gt;setId(1);
$user-&gt;setUsername('jwage');

$om = $this-&gt;getYourObjectManager();
$om-&gt;persist($user);
$om-&gt;flush(); // insert the new document
</code></pre>

<p>Then you can find that object later and modify it:</p>

<pre><code>&lt;?php

$user = $om-&gt;find('User', 1);
echo $user-&gt;getUsername(); // prints "jwage"

$user-&gt;setUsername('jonwage'); // change the obj in memory

$om-&gt;flush(); // updates the object in the database
</code></pre>

<p>You can find more information about the supported object mappers below:</p>

<p><strong><a href="http://github.com/doctrine/doctrine2" target="_blank">doctrine/orm</a></strong></p>

<p>Doctrine ORM provides persistence for PHP objects to relational database.</p>

<p><strong><a href="http://github.com/doctrine/couchdb-odm" target="_blank">doctrine/couchdb-odm</a></strong></p>

<p>Doctrine CouchDB ODM provides persistence for PHP objects to CouchDB.</p>

<p><strong><a href="http://github.com/doctrine/phpcr-odm" target="_blank">doctrine/phpcr-odm</a></strong></p>

<p>Doctrine PHPCR (Content Repository) ODM provides persistence to a backend like Jackalope or Midgard2. This is a specialized object mapper for dealing with data designed for building content websites. Think of this like a backend for a CMS (Content Management System).</p>

<p><strong><a href="http://github.com/doctrine/mongodb-odm" target="_blank">doctrine/mongodb-odm</a></strong></p>

<p>Doctrine MongoDB ODM provides persistence for PHP objects to MongoDB. You can read more about the MongoDB ODM <a href="http://jwage.com/post/30490170860/doctrine-mongodb-object-document-mapper-in-symfony2" target="_blank">here</a>.</p>

<p><strong><a href="http://github.com/doctrine/orientdb-odm" target="_blank">doctrine/orientdb-odm</a></strong></p>

<p>Doctrine OrientDB ODM provides persistence for PHP objects to OrientDB.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Sending Safari Push Notifications with PHP]]></title>
            <link href="https://jwage.com/posts/2013/12/23/sending-safari-push-notifications-with-php"/>
            <updated>2013-12-23T00:00:00-05:00</updated>
            <id>https://jwage.com/posts/2013/12/23/sending-safari-push-notifications-with-php</id>
            <content type="html"><![CDATA[<p>When OSX Mavericks was released, I was excited to see that push notifications were supported within Safari. So now, just like iOS, we can send push notifications to Safari regardless of whether the browser is open or not. This post gives overview of how to get them working from PHP using the <a href="http://github.com/jwage/php-apns" target="_blank">PHP APNS</a> library.</p>

<h3>Registering with Apple and Generating Certificates</h3>

<p>This post assumes you have read <a href="https://developer.apple.com/library/mac/documentation/NetworkingInternet/Conceptual/NotificationProgrammingGuideForWebsites/PushNotifications/PushNotifications.html#//apple_ref/doc/uid/TP40013225-CH3-SW1" target="_blank">this</a> article from Apple and have already generated your security certificates.</p>

<h3>PHP APNS Library</h3>

<p>The PHP APNS (Apple Push Notification Service) library makes it extremely easy to get Safari push notifications working on your website. Just install it with composer to get started:</p>

<h3>Installation</h3>

<pre><code>composer require jwage/php-apns
composer install
</code></pre>

<h3>Push Package</h3>

<p>Once you have the package installed you can start integrating it with your website. The first thing we need to do is create a base push package for your website. From Apple&rsquo;s website:</p>

<blockquote>
  <p>When a user is asked for permission to receive push notifications, Safari asks your web server for a package. The package contains data that is used by the notification UI, such as your website name and icon, as well as a cryptographic signature. The signature verifies that your notification hasn’t been intercepted by a man-in-the-middle attack and that it is indeed coming from a trusted source: you.</p>
</blockquote>

<p>You can find a sample base push package within the PHP APNS library <a href="https://github.com/jwage/php-apns/tree/master/data/safariPushPackage.base" target="_blank">here</a>. Copy this somewhere in your application and customize the icons in the icon.iconset folder and the website.json:</p>

<pre><code>{
    "websiteName": "WebsiteName",
    "websitePushID": "web.com.domain",
    "allowedDomains": ["http://", "https://"],
    "urlFormatString": "http:///%@",
    "authenticationToken": "",
    "webServiceURL": "https:///safari_push_notifications/"
}
</code></pre>

<h3>Web Service Endpoints</h3>

<p>Now it is time to setup some endpoints in your web application for Safari to communicate with. You need endpoints to do the following:</p>

<ul><li>Generate a push package for an individual user.</li>
<li>Register a users device token.</li>
<li>Deregister a users device token.</li>
<li>Record log data sent by Safari when errors occur.</li>
</ul>

<p>Here is a pseudo controller demonstrating what each endpoint needs to do:</p>

<pre><code>&lt;?php

namespace App\Controller;

use JWage\APNS\Certificate;
use JWage\APNS\Safari\PackageGenerator;

class SafariPushNotificationsController
{
    public function packageAction($userId)
    {
        // Send push notification package to browser when Safari asks user for permission to send you notifications.

        $certificate = new Certificate(file_get_contents('apns.p12'), 'certpassword');
        $packageGenerator = new PackageGenerator(
            $certificate, '/path/to/base/pushPackage/path', 'yourhost.com'
        );

        // returns JWage\APNS\Safari\Package instance
        $package = $packageGenerator-&gt;createPushPackageForUser('userid');

        // send $package-&gt;getZipPath() to the browser
    }

    public function registerAction($userId, $deviceToken)
    {
        // store $deviceToken on the $userId so you can use it later to send pushes
    }

    public function deregisterAction($userId, $deviceToken)
    {
        // remove $deviceToken from $userId
    }

    public function logAction($userId)
    {
        // log information sent for debugging purposes
    }
}
</code></pre>

<h3>Requesting Permission</h3>

<p>Requesting permission to send a user notifications in Safari can be done using this little snippet of javascript on your website:</p>

<pre><code>if ('safari' in window &amp;&amp; 'pushNotification' in window.safari) {
    var checkRemotePermission = function (permissionData) {
        if (permissionData.permission === 'default') {
            window.safari.pushNotification.requestPermission(
                'http://domain.com/safari_push_notifications/',
                'web.com.domain',
                {
                    'userId': 
                },
                checkRemotePermission
            );
        } else if (permissionData.permission === 'denied') {
            // do something when permission is denied
        } else if (permissionData.permission === 'granted') {
            // do something when permission is granted
        }
    };

    // Ensure that the user can receive Safari Push Notifications.
    var permissionData = window.safari.pushNotification.permission('web.com.domain');
    checkRemotePermission(permissionData);
}
</code></pre>

<p>When a user visits your website with Safari in OSX Mavericks it will hit your web services endpoint, download the push package and ask the user if they want to receive notifications from your website.</p>

<h3>Sending Push Notifications</h3>

<p>Once you have done all of the above, you should be ready to send push notifications. The PHP APNS library makes this extremely easy. Here is an example:</p>

<pre><code>use JWage\APNS\Certificate;
use JWage\APNS\Client;
use JWage\APNS\Sender;
use JWage\APNS\SocketClient;

$certificate = new Certificate(file_get_contents('apns.pem'));
$socketClient = new SocketClient($certificate, 'gateway.push.apple.com', 2195);
$client = new Client($socketClient);
$sender = new Sender($client);

$sender-&gt;send('devicetoken', 'Title of push', 'Body of push', 'http://deeplink.com');
</code></pre>

<p>You can create an easy to use service in your application for sending push notifications to an instance of <code>User</code>, assuming it implements a <code>getSafariDeviceToken()</code> method:</p>

<pre><code>class SafariPushNotificationSender
{
    private $sender;

    public function __construct(Sender $sender)
    {
        $this-&gt;sender = $sender;
    }

    public function sendToUser(User $user, $title, $body, $link)
    {
        return $this-&gt;sender-&gt;send($user-&gt;getSafariDeviceToken(), $title, $body, $link);
    }
}
</code></pre>

<p>Now it is as simple as the following:</p>

<pre><code>$safariPushNotificationSender = new SafariPushNotificationSender($sender);
$safariPushNotificationSender-&gt;sendToUser($user, 'Title of push', 'Body of push', 'http://deeplink.com');
</code></pre>

<p>I hope this was helpful! If you have any questions please leave them in the comments. Enjoy!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[MongoDB PHP MongoDate Tricks]]></title>
            <link href="https://jwage.com/posts/2013/07/16/mongodb-php-mongodate-tricks"/>
            <updated>2013-07-16T00:00:00-04:00</updated>
            <id>https://jwage.com/posts/2013/07/16/mongodb-php-mongodate-tricks</id>
            <content type="html"><![CDATA[<p>Here are a few tricks I&rsquo;ve learned working with MongoDB and PHP.</p>

<p><strong>Create DateTime from MongoId</strong></p>

<p>Because MongoDB identifiers contain the date you can easily create a <code>DateTime</code> instance from them.</p>

<pre><code>public function getDateTimeFromMongoId(MongoId $mongoId)
{
    $dateTime = new DateTime('@'.$mongoId-&gt;getTimestamp());
    $dateTime-&gt;setTimezone(new DateTimeZone(date_default_timezone_get()));
    return $dateTime;
}
</code></pre>

<p>This is useful when you don&rsquo;t want to create an additional field to store the date a document was created. You can also use the _id index that already exists to paginate and filter/sort by date.</p>

<p><strong>Create MongoId with Date in the Past</strong></p>

<p>For the same reason as above, you can create a MongoId instance with a date in the past. This was copied from a <a href="http://stackoverflow.com/questions/14370143/create-mongodb-objectid-from-date-in-the-past-using-php-driver/14380093#14380093" target="_blank">stackoverflow answer</a> by <a href="http://derickrethans.nl/" target="_blank">Derek Rethans</a>.</p>

<pre><code>public createMongoIdFromTimestamp($timestamp)
{
    $ts = pack('N', $timestamp);
    $m = substr(md5(gethostname()), 0, 3);
    $pid = pack('n', posix_getpid());
    $trail = substr(pack('N', $this-&gt;inc++), 1, 3);

    $bin = sprintf('%s%s%s%s', $ts, $m, $pid, $trail);

    $id = '';
    for ($i = 0; $i &lt; 12; $i++ ) {
        $id .= sprintf('%02X', ord($bin[$i]));
    }

    return new \MongoID($id);
}
</code></pre>

<p>This was useful when migrating legacy data in to a collection where we utilize the _id for pagination and displaying a created date. If we simply created identifiers with todays date then it would show old records with all the same date and pagination/sorting would be broken.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Tracking New Member Origination with Symfony2]]></title>
            <link href="https://jwage.com/posts/2013/07/08/tracking-new-member-origination-with-symfony2"/>
            <updated>2013-07-08T00:00:00-04:00</updated>
            <id>https://jwage.com/posts/2013/07/08/tracking-new-member-origination-with-symfony2</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>NOTE</strong>
  The example code in this blog post has been simplified to make things more concise and easy to read.</p>
</blockquote>

<p>At <a href="http://www.opensky.com" target="_blank">OpenSky</a> it is important for us to track how a member joined so that we can determine causation between joining and any subsequent actions taken on the site, like an order.</p>

<p>To get started create a new class called <code>OriginationManager</code> with a method named <code>updateHistory</code>. It will accept a <code>Request</code> object and record the query parameters from the current URL in the session.</p>

<pre><code>&lt;?php class OriginationManager
{
    public function updateHistory(Request $request)
    {
        $session = $request-&gt;getSession();

        $history = $session-&gt;get('user_origination_history', array());
        $history[] = $request-&gt;query-&gt;all();

        $session-&gt;set('user_origination_history', $history);
    }
}
</code></pre>

<p>Now create an <code>OriginationListener</code> class that will listen to the <code>kernel.request</code> event and make use of the <code>OriginationManager::updateHistory()</code> API we just created.</p>

<pre><code>&lt;?php class OriginationListener
{
    // ...

    public function onKernelRequest(GetResponseEvent $event)
    {
        $request = $event-&gt;getRequest();

        // Only process non-logged-in users
        if ($token = $this-&gt;securityContext-&gt;getToken()) {
            $user = $token-&gt;getUser();
            if ($user instanceof User) {
                return;
            }
        }

        $this-&gt;originationManager-&gt;updateHistory($request);
    }
}
</code></pre>

<p>Now we are tracking the query parameters of logged out users on every request. We can make use of this information later when a user joins. First, lets define a new model that can be used to store the origination information along with the user (assume the model is persisted with <a href="http://www.doctrine-project.org" target="_blank">Doctrine</a>). Each new <code>User</code> gets an <code>Originator</code> record when they join. It allows us to essentially see how a new user entered the site and what clicks they made before joining.</p>

<pre><code>&lt;?php class Originator
{
    /**
     * The raw array of request query data.
     *
     * @var array
     */
    protected $history = array();

    /**
     * The user that originated this member.
     *
     * @var User
     */
    protected $user;

    /**
     * The value of the first osky_origin parameter we encounter.
     *
     * @var string
     */
    protected $origin;

    /**
     * The value of the first osky_source parameter we encounter.
     *
     * @var string
     */
    protected $source;

    // ...
}
</code></pre>

<p>Assume your application already notifies an event named <code>user.created</code>. In <code>OriginationListener</code> create an <code>onUserCreated</code> method that will listen to the <code>user.created</code> event.</p>

<pre><code>&lt;?php

class OriginationListener
{
    // ...

    public function onUserCreated(UserCreatedEvent $event)
    {
        $user = $event-&gt;getUser();
        $request = $event-&gt;getRequest();

        $this-&gt;originationManager-&gt;assignUserOrigination($user, $request);
    }
}
</code></pre>

<p>Next, create the <code>OriginationManager::assignUserOrigination()</code> method. It will utilize the request query parameters we saved on the session earlier to create a new <code>Originator</code> record.</p>

<pre><code>&lt;?php class OriginationManager
{
    public function assignUserOrigination(User $user, Request $request)
    {
        $session = $request-&gt;getSession();

        $history = $session-&gt;get('user_origination_history', array());

        $originator = new Originator();
        $originator-&gt;setHistory($history);

        foreach ($history as $query) {
            if (!$originator-&gt;getOrigin() &amp;&amp; isset($query['osky_origin'])) {
                $originator-&gt;setOrigin($query['osky_origin']);

                if ($user = $this-&gt;userRepository-&gt;find($query['osky_origin'])) {
                    $originator-&gt;setUser($user);
                }
            }

            if (!$originator-&gt;getSource() &amp;&amp; isset($query['osky_source'])) {
                $originator-&gt;setSource($query['osky_source']);
            }
        }

        $user-&gt;setOriginator($originator);

        $session-&gt;remove('user_origination_history');
    }
}
</code></pre>

<p>Now if a logged out user were to visit OpenSky with a parameter named <code>osky_origin</code> in the URL with another users id as the value, the <code>Originator</code> record that gets created for the new member will have a reference to that <code>User</code>. We can then utilize that information do whatever we want. In our case we give the user that got the new <code>User</code> to join a credit and a thank you. The <code>osky_source</code> parameter can be used as an arbitrary reporting variable to help with identifying marketing campaigns.</p>

<p>Keep in mind that this is an example implementation and it omits many details specific to OpenSky for the sake of simplicity. The real implementation we use has dozens of other parameters that can be used to associate records together and assist with reporting. You can add to this implementation and check for custom parameters and standard ones like <code>utm_source</code>, <code>utm_campaign</code>, etc.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Building Activity Streams using Symfony2, Doctrine2 and MongoDB]]></title>
            <link href="https://jwage.com/posts/2013/07/02/building-activity-streams"/>
            <updated>2013-07-02T00:00:00-04:00</updated>
            <id>https://jwage.com/posts/2013/07/02/building-activity-streams</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>NOTE</strong>
  The example code in this blog post has been simplified to make things more concise and easy to read.</p>
</blockquote>

<p>At <a href="http://www.opensky.com" target="_blank">OpenSky</a> we utilize <a href="http://symfony.com" target="_blank">Symfony2</a>, <a href="http://doctrine-project.org" target="_blank">Doctrine2</a> and <a href="http://www.mongodb.org/" target="_blank">MongoDB</a> for streams of activity across our site. We&rsquo;ve based our implementation on the <a href="http://activitystrea.ms/specs/json/1.0/" target="_blank">JSON Activity Streams 1.0</a> specification. This blog post demonstrates how you can easily setup your own activity streams.</p>

<p>An activity item consists of a published date, actor, object, target and verb. It describes an action performed by an entity. Here is an example JSON document of what an activity item might look like:</p>

<pre><code>{
  "published": "2011-02-10T15:04:55Z",
  "actor": {
    "url": "http://example.org/martin",
    "objectType" : "person",
    "id": "tag:example.org,2011:martin",
    "image": {
      "url": "http://example.org/martin/image",
      "width": 250,
      "height": 250
    },
    "displayName": "Martin Smith"
  },
  "verb": "post",
  "object" : {
    "url": "http://example.org/blog/2011/02/entry",
    "id": "tag:example.org,2011:abc123/xyz"
  },
  "target" : {
    "url": "http://example.org/blog/",
    "objectType": "blog",
    "id": "tag:example.org,2011:abc123",
    "displayName": "Martin's Blog"
  }
}
</code></pre>

<p>To get started implementing this let&rsquo;s define a base PHP class that we can use to represent an activity item.</p>

<pre><code>&lt;?php

namespace Project\Document;

use Doctrine\ODM\MongoDB\Mapping\Annotations as ODM;

/**
 * @ODM\MappedSuperclass(collection="activity_items")
 * @ODM\InheritanceType("SINGLE_COLLECTION")
 * @ODM\DiscriminatorField(fieldName="verb")
 * @ODM\DiscriminatorMap({
 *     "love" = "Project\Document\LoveActivityItem"
 * })
 */
abstract class AbstractActivityItem
{
    /** @ODM\Date */
    protected $published;

    protected $actor;
    protected $object;
    protected $target;

    // ...
}
</code></pre>

<p>For this blog post we&rsquo;re only going to implement one verb called <code>love</code>. On OpenSky you can love products and the action is pushed in to the feed of your followers. So let&rsquo;s get started implementing the <code>LoveActivityItem</code> class:</p>

<pre><code>&lt;?php

namespace Project\Document;

use Doctrine\ODM\MongoDB\Mapping\Annotations as ODM;
use Project\Document\Love;
use Project\Document\Product;
use Project\Document\User;

/** @ODM\Document */
class LoveActivityItem extends AbstractActivityItem
{
    /** @ODM\ReferenceOne(targetDocument="User") */
    protected $actor;

    /** @ODM\ReferenceOne(targetDocument="Love") */
    protected $object;

    /** @ODM\ReferenceOne(targetDocument="Product") */
    protected $target;

    public function __construct(
        User $user, Love $love, Product $product
    )
    {
        $this-&gt;actor = $user;
        $this-&gt;object = $love;
        $this-&gt;target = $product;
    }

    // ...
}
</code></pre>

<p>Now that we have our basic model defined, let&rsquo;s implement the code that will wire everything up. Assume we already have a Symfony event in our application being notified called <code>user.love</code>. So setup a listener that listens to that event and records the activity item:</p>

<pre><code>&lt;?php

namespace Project/Listener;

class ActivityListener
{
    /**
     * @var Project\Activity\ActivityManager
     */
    private $activityManager;

    /**
     * Listens to the `user.love` event.
     */
    public function onUserLove(UserLoveEvent $event)
    {
        $this-&gt;activityManager-&gt;recordUserLove(
            $event-&gt;getUser(),
            $event-&gt;getLove()
        );
    }
}
</code></pre>

<p>Now let&rsquo;s implement the <code>ActivityManager</code> class with the <code>recordUserLove</code> method:</p>

<pre><code>&lt;?php

namespace Project\Activity;

use Doctrine\ODM\MongoDB\DocumentManager;
use Project\Document\LoveActivityItem;
use Project\Document\Love;
use Project\Document\User;

class ActivityManager
{
    private $dm;

    public function __construct(DocumentManager $dm)
    {
        $this-&gt;dm = $dm;
    }

    public function recordUserLove(User $user, Love $love)
    {
        $this-&gt;dm-&gt;persist(
            new LoveActivityItem($user, $love, $love-&gt;getProduct())
        );
    }
}
</code></pre>

<p>The new activity item will get flushed to the database at the end of the action with the love since we flush in the controller where the <code>user.love</code> event is notified. Now it is possible to generate a feed of activity items for the whole site, a specific user or even a set of users:</p>

<pre><code>&lt;?php

$user = $dm-&gt;getRepository('Project\Document\User')-&gt;findOneByEmail('jonwage@gmail.com');

$activityItems = $dm-&gt;getRepository('Project\Document\ActivityItem')
    -&gt;createQueryBuilder()
    -&gt;field('actor')-&gt;references($user)
    -&gt;getQuery()
    -&gt;execute();
</code></pre>

<p>That is it. You can easily add new verbs to the model and add code to the listener and manager to record new activities. Good luck! I hope this was helpful for someone!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Doctrine Common Library]]></title>
            <link href="https://jwage.com/posts/2012/09/24/doctrine-common-library"/>
            <updated>2012-09-24T00:00:00-04:00</updated>
            <id>https://jwage.com/posts/2012/09/24/doctrine-common-library</id>
            <content type="html"><![CDATA[<p><a href="http://doctrine-project.org" target="_blank">Doctrine</a> started as a library where all the internal components were coupled together. But as things have evolved the components have been decoupled and shared between the projects. This change also makes it possible for other people to use these pieces of Doctrine even if they don&rsquo;t use the ORM or any other project.</p>

<p>The <a href="https://github.com/doctrine/common/tree/master/lib/Doctrine/Common" target="_blank">Doctrine\Common</a> namespace contains a few things like:</p>

<ul><li><a href="https://github.com/doctrine/common/tree/master/lib/Doctrine/Common/Annotations" target="_blank">DocBlock Annotations Library</a> - annotations library used by <a href="http://symfony.com" target="_blank">Symfony</a>, <a href="http://drupal.org" target="_blank">Drupal</a> and other popular PHP projects.</li>
<li><a href="https://github.com/doctrine/common/tree/master/lib/Doctrine/Common/Cache" target="_blank">Cache Drivers</a> - APC, Memcache, etc. cache drivers.</li>
<li><a href="https://github.com/doctrine/common/tree/master/lib/Doctrine/Common/Persistence" target="_blank">Persistence</a> - Shared base classes and interfaces across the object mappers.</li>
<li><a href="https://github.com/doctrine/common/blob/master/lib/Doctrine/Common/Lexer.php" target="_blank">Lexer Parser</a> - Base class for writing simple lexers, i.e. for creating small DSLs. I recently wrote a blog post about it <a href="http://jwage.com/post/31623163785/writing-a-parser-in-php-with-the-help-of-doctrine" target="_blank">here</a>.</li>
</ul>

<p><strong>DocBlock AnnotationsLibrary</strong></p>

<p>With the annotations library you can parse information out of your DocBlocks in to PHP objects. The object mapper projects use this feature for specifying entity mapping information in the DocBlocks of your classes, properties and methods. Here is an example of what an entity looks like in the ORM:</p>

<pre><code>namespace MyProject\Entities;

use Doctrine\ORM\Mapping AS ORM;
use Symfony\Component\Validation\Constraints AS Assert;

/**
 * @ORM\Entity
 */
class User
{
    /**
     * @ORM\Id @ORM\Column @ORM\GeneratedValue
     */
    private $id;

    /**
     * @ORM\Column(type="string")
     * @Assert\NotEmpty
     * @Assert\Email
     */
    private $email;
}
</code></pre>

<p><strong>Cache Drivers</strong></p>

<p>The cache drivers provide a common interface to cache backends in PHP. Here are the supported drivers:</p>

<ul><li>ApcCache</li>
<li>ArrayCache</li>
<li>FileCache</li>
<li>FilesystemCache</li>
<li>MemcacheCache</li>
<li>MemcachedCache</li>
<li>PhpFileCache</li>
<li>RedisCache</li>
<li>WinCacheCache</li>
<li>XcacheCache</li>
<li>ZendDataCache</li>
</ul>

<p>The interface is very simple:</p>

<pre><code>function fetch($id);
function contains($id);
function save($id, $data, $lifeTime = 0);
function delete($id);
function getStats();
</code></pre>

<p><strong>Persistence Library</strong></p>

<p>The persistence interfaces are implemented by the object mapper libraries. They provide the common base classes and interfaces that a Doctrine object persistence library should implement, such as:</p>

<p><strong>ObjectManager</strong></p>

<pre><code>function find($className, $id);
function persist($object);
function remove($object);
function merge($object);
function clear($objectName = null);
function detach($object);
function refresh($object);
function flush();
function getRepository($className);
function getClassMetadata($className);
function getMetadataFactory();
function initializeObject($obj);
function contains($object);
</code></pre>

<p><strong>ObjectRepository</strong></p>

<pre><code>function find($id);
function findAll();
function findBy(array $criteria, array $orderBy = null, $limit = null, $offset = null);
function findOneBy(array $criteria);
function getClassName();
</code></pre>

<p><strong>ClassMetadataFactory</strong></p>

<pre><code>function getAllMetadata();
function getMetadataFor($className);
function hasMetadataFor($className);
function setMetadataFor($className, $class);
function isTransient($className);
</code></pre>

<p><strong>ClassMetadata</strong></p>

<pre><code>function getName();
function getIdentifier();
function getReflectionClass();
function isIdentifier($fieldName);
function hasField($fieldName);
function hasAssociation($fieldName);
function isSingleValuedAssociation($fieldName);
function isCollectionValuedAssociation($fieldName);
function getFieldNames();
function getIdentifierFieldNames();
function getAssociationNames();
function getTypeOfField($fieldName);
function getAssociationTargetClass($assocName);
function isAssociationInverseSide($assocName);
function getAssociationMappedByTargetField($assocName);
function getIdentifierValues($object);
</code></pre>

<p>The <code>Doctrine\Common</code> namespace contains lots more than I have mentioned here. So if you want to learn more check it out on <a href="https://github.com/doctrine/common/tree/master/lib/Doctrine/Common" target="_blank"><code>GitHub</code></a> or read the <a href="http://docs.doctrine-project.org/projects/doctrine-common/en/latest/index.html" target="_blank">documentation</a>. It is not that complete yet but it has some useful information.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Writing a parser in PHP with the help of Doctrine]]></title>
            <link href="https://jwage.com/posts/2012/09/15/writing-a-parser-in-php-with-the-help-of-doctrine"/>
            <updated>2012-09-15T00:00:00-04:00</updated>
            <id>https://jwage.com/posts/2012/09/15/writing-a-parser-in-php-with-the-help-of-doctrine</id>
            <content type="html"><![CDATA[<p>In the <a href="http://doctrine-project.org" target="_blank">Doctrine</a> project we have a SQL-like language called <a href="http://doctrine-orm.readthedocs.org/en/2.0.x/reference/dql-doctrine-query-language.html" target="_blank">DQL</a> for the ORM. In Doctrine1 the DQL language was not implemented with a true parser but in Doctrine2 the language was completely re-written with a true lexer parser. This lexer parser not only powers DQL but it also powers the <a href="http://jwage.com/post/30490186668/doctrine-annotations-library" target="_blank">Annotations</a> library in the <a href="http://www.doctrine-project.org/projects/common.html" target="_blank">Common</a> library.</p>

<p>To write your own parser you just need to extend <a href="https://github.com/doctrine/common/blob/master/lib/Doctrine/Common/Lexer.php" target="_blank"><code>Doctrine\Common\Lexer</code></a> and implement the following three abstract methods. These methods define the <a href="http://en.wikipedia.org/wiki/Lexical_analysis" target="_blank">lexical</a> catchable and non-catchable patterns and a method for returning the type of a token and filtering the value if necessary.</p>

<pre><code>/**
 * Lexical catchable patterns.
 *
 * @return array
 */
abstract protected function getCatchablePatterns();

/**
 * Lexical non-catchable patterns.
 *
 * @return array
 */
abstract protected function getNonCatchablePatterns();

/**
 * Retrieve token type. Also processes the token value if necessary.
 *
 * @param string $value
 * @return integer
 */
abstract protected function getType(&amp;$value);
</code></pre>

<p>Here is an example. The <a href="https://github.com/doctrine/doctrine2/blob/master/lib/Doctrine/ORM/Query/Lexer.php" target="_blank"><code>Doctrine\ORM\Query\Lexer</code></a> implementation for DQL looks like the following:</p>

<pre><code>namespace Doctrine\ORM\Query;

class Lexer extends \Doctrine\Common\Lexer
{
    // All tokens that are not valid identifiers must be &lt; 100
    const T_NONE                = 1;
    const T_INTEGER             = 2;
    const T_STRING              = 3;
    const T_INPUT_PARAMETER     = 4;
    const T_FLOAT               = 5;
    const T_CLOSE_PARENTHESIS   = 6;
    const T_OPEN_PARENTHESIS    = 7;
    const T_COMMA               = 8;
    const T_DIVIDE              = 9;
    const T_DOT                 = 10;
    const T_EQUALS              = 11;
    const T_GREATER_THAN        = 12;
    const T_LOWER_THAN          = 13;
    const T_MINUS               = 14;
    const T_MULTIPLY            = 15;
    const T_NEGATE              = 16;
    const T_PLUS                = 17;
    const T_OPEN_CURLY_BRACE    = 18;
    const T_CLOSE_CURLY_BRACE   = 19;

    // All tokens that are also identifiers should be &gt;= 100
    const T_IDENTIFIER          = 100;
    const T_ALL                 = 101;
    const T_AND                 = 102;
    const T_ANY                 = 103;
    const T_AS                  = 104;
    const T_ASC                 = 105;
    const T_AVG                 = 106;
    const T_BETWEEN             = 107;
    const T_BOTH                = 108;
    const T_BY                  = 109;
    const T_CASE                = 110;
    const T_COALESCE            = 111;
    const T_COUNT               = 112;
    const T_DELETE              = 113;
    const T_DESC                = 114;
    const T_DISTINCT            = 115;
    const T_EMPTY               = 116;
    const T_ESCAPE              = 117;
    const T_EXISTS              = 118;
    const T_FALSE               = 119;
    const T_FROM                = 120;
    const T_GROUP               = 121;
    const T_HAVING              = 122;
    const T_IN                  = 123;
    const T_INDEX               = 124;
    const T_INNER               = 125;
    const T_INSTANCE            = 126;
    const T_IS                  = 127;
    const T_JOIN                = 128;
    const T_LEADING             = 129;
    const T_LEFT                = 130;
    const T_LIKE                = 131;
    const T_MAX                 = 132;
    const T_MEMBER              = 133;
    const T_MIN                 = 134;
    const T_NOT                 = 135;
    const T_NULL                = 136;
    const T_NULLIF              = 137;
    const T_OF                  = 138;
    const T_OR                  = 139;
    const T_ORDER               = 140;
    const T_OUTER               = 141;
    const T_SELECT              = 142;
    const T_SET                 = 143;
    const T_SIZE                = 144;
    const T_SOME                = 145;
    const T_SUM                 = 146;
    const T_TRAILING            = 147;
    const T_TRUE                = 148;
    const T_UPDATE              = 149;
    const T_WHEN                = 150;
    const T_WHERE               = 151;
    const T_WITH                = 153;
    const T_PARTIAL             = 154;
    const T_MOD                 = 155;

    /**
     * Creates a new query scanner object.
     *
     * @param string $input a query string
     */
    public function __construct($input)
    {
        $this-&gt;setInput($input);
    }

    /**
     * @inheritdoc
     */
    protected function getCatchablePatterns()
    {
        return array(
            '[a-z_\\\][a-z0-9_\:\\\]*[a-z0-9_]{1}',
            '(?:[0-9]+(?:[\.][0-9]+)*)(?:e[+-]?[0-9]+)?',
            "'(?:[^']|'')*'",
            '\?[0-9]*|:[a-z]{1}[a-z0-9_]{0,}'
        );
    }

    /**
     * @inheritdoc
     */
    protected function getNonCatchablePatterns()
    {
        return array('\s+', '(.)');
    }

    /**
     * @inheritdoc
     */
    protected function getType(&amp;$value)
    {
        $type = self::T_NONE;

        // Recognizing numeric values
        if (is_numeric($value)) {
            return (strpos($value, '.') !== false || stripos($value, 'e') !== false)
                    ? self::T_FLOAT : self::T_INTEGER;
        }

        // Differentiate between quoted names, identifiers, input parameters and symbols
        if ($value[0] === "'") {
            $value = str_replace("''", "'", substr($value, 1, strlen($value) - 2));
            return self::T_STRING;
        } else if (ctype_alpha($value[0]) || $value[0] === '_') {
            $name = 'Doctrine\ORM\Query\Lexer::T_' . strtoupper($value);

            if (defined($name)) {
                $type = constant($name);

                if ($type &gt; 100) {
                    return $type;
                }
            }

            return self::T_IDENTIFIER;
        } else if ($value[0] === '?' || $value[0] === ':') {
            return self::T_INPUT_PARAMETER;
        } else {
            switch ($value) {
                case '.': return self::T_DOT;
                case ',': return self::T_COMMA;
                case '(': return self::T_OPEN_PARENTHESIS;
                case ')': return self::T_CLOSE_PARENTHESIS;
                case '=': return self::T_EQUALS;
                case '&gt;': return self::T_GREATER_THAN;
                case '&lt;': return self::T_LOWER_THAN;
                case '+': return self::T_PLUS;
                case '-': return self::T_MINUS;
                case '*': return self::T_MULTIPLY;
                case '/': return self::T_DIVIDE;
                case '!': return self::T_NEGATE;
                case '{': return self::T_OPEN_CURLY_BRACE;
                case '}': return self::T_CLOSE_CURLY_BRACE;
                default:
                    // Do nothing
                    break;
            }
        }

        return $type;
    }
}
</code></pre>

<p>The <code>Lexer</code> parser is responsible for giving you an API to walk across a string and analyze the type, value and position of each token in the string. The low level API of the lexer is pretty simple:</p>

<ul><li><strong>setInput($input)</strong> - Sets the input data to be tokenized. The Lexer is immediately reset and the new input tokenized.</li>
<li><strong>reset()</strong> - Resets the lexer.</li>
<li><strong>resetPeek()</strong> - Resets the peek pointer to 0.</li>
<li><strong>resetPosition($position = 0)</strong> - Resets the lexer position on the input to the given position.</li>
<li><strong>isNextToken($token)</strong> - Checks whether a given token matches the current lookahead.</li>
<li><strong>isNextTokenAny(array $tokens)</strong> - Checks whether any of the given tokens matches the current lookahead.</li>
<li><strong>moveNext()</strong> - Moves to the next token in the input string.</li>
<li><strong>skipUntil($type)</strong> - Tells the lexer to skip input tokens until it sees a token with the given value.</li>
<li><strong>isA($value, $token)</strong> - Checks if given value is identical to the given token.</li>
<li><strong>peek()</strong> - Moves the lookahead token forward.</li>
<li><strong>glimpse()</strong> - Peeks at the next token, returns it and immediately resets the peek.</li>
</ul>

<p>Put it all together and this is what you get. This is what the Doctrine ORM DQL parser implementation looks like:</p>

<pre><code>class Parser
{
    private $lexer;

    public function __construct($dql)
    {
        $this-&gt;lexer = new Lexer();
        $this-&gt;lexer-&gt;setInput($dql);
    }

    // ...

    public function getAST()
    {
        // Parse &amp; build AST
        $AST = $this-&gt;QueryLanguage();

        // ...

        return $AST;
    }

    public function QueryLanguage()
    {
        $this-&gt;lexer-&gt;moveNext();

        switch ($this-&gt;lexer-&gt;lookahead['type']) {
            case Lexer::T_SELECT:
                $statement = $this-&gt;SelectStatement();
                break;
            case Lexer::T_UPDATE:
                $statement = $this-&gt;UpdateStatement();
                break;
            case Lexer::T_DELETE:
                $statement = $this-&gt;DeleteStatement();
                break;
            default:
                $this-&gt;syntaxError('SELECT, UPDATE or DELETE');
                break;
        }

        // Check for end of string
        if ($this-&gt;lexer-&gt;lookahead !== null) {
            $this-&gt;syntaxError('end of string');
        }

        return $statement;
    }

    // ...
}

$parser = new Parser('SELECT u FROM User u');
$AST = $parser-&gt;getAST(); // returns \Doctrine\ORM\Query\AST\SelectStatement
</code></pre>

<p>What is an AST? AST stands for <a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank">Abstract syntax tree</a>:</p>

<blockquote>In computer science, an abstract syntax tree (AST), or just syntax tree, is a tree representation of the abstract syntactic structure of source code written in a programming language. Each node of the tree denotes a construct occurring in the source code.</blockquote>

<p>Now the AST is used to transform the DQL query in to portable SQL for whatever relational database you are using! Cool!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Ruler: A simple stateless production rules engine for PHP 5.3+]]></title>
            <link href="https://jwage.com/posts/2012/09/10/ruler-a-simple-stateless-production-rules-engine"/>
            <updated>2012-09-10T00:00:00-04:00</updated>
            <id>https://jwage.com/posts/2012/09/10/ruler-a-simple-stateless-production-rules-engine</id>
            <content type="html"><![CDATA[<p><strong>What is ruler?</strong></p>

<p><a href="https://github.com/bobthecow/ruler" target="_blank">Ruler</a> is a simple stateless production rules engine for PHP 5.3+ written by <a href="http://twitter.com/bobthecow" target="_blank">Justin Hileman (@bobthecow)</a>. Justin was previously employed at <a href="https://opensky.com" target="_blank">OpenSky</a> but these days you will find him hacking on a new startup named <a href="https://twitter.com/presentate" target="_blank">@presentate</a>.</p>

<p><strong>What is a rules engine?</strong></p>

<p>From <a href="http://martinfowler.com/bliki/RulesEngine.html" target="_blank">martinfowler.com</a>:</p>

<blockquote>A rules engine is all about providing an alternative computational model. Instead of the usual imperative model, commands in sequence with conditionals and loops, it provides a list of production rules. Each rule has a condition and an action - simplistically you can think of it as a bunch of if-then statements.</blockquote>

<p>From <a href="http://en.wikipedia.org/wiki/Business_rules_engine" target="_blank">wikipedia</a>:</p>

<blockquote>A business rules engine is a software system that executes one or more business rules in a runtime production environment. The rules might come from legal regulation (&ldquo;An employee can be fired for any reason or no reason but not for an illegal reason&rdquo;), company policy (&ldquo;All customers that spend more than $100 at one time will receive a 10% discount&rdquo;), or other sources. A business rule system enables these company policies and other operational decisions to be defined, tested, executed and maintained separately from application code.</blockquote>

<p><strong>What does Ruler usage look like?</strong></p>

<p>Ruler has a nice and convenient DSL that is provided by <code>RuleBuilder</code>:</p>

<pre><code>$rb = new RuleBuilder;
$rule = $rb-&gt;create(
    $rb-&gt;logicalAnd(
        $rb['minAge']-&gt;greaterThan($rb['age']),
        $rb['maxAge']-&gt;lessThan($rb['age'])
    ),
    function() {
        echo 'Congratulations! You are between the ages of 18 and 25!';
    }
);

$context = new Context(array(
    'minAge' =&gt; 18,
    'maxAge' =&gt; 25,
    'age' =&gt; function() {
        return 20;
    },
));

$rule-&gt;execute($context); // "Congratulations! You are between the ages of 18 and 25!"
</code></pre>

<p>The full API is quite simple:</p>

<pre><code>// These are Variables. They'll be replaced by terminal values during Rule evaluation.

$a = $rb['a'];
$b = $rb['b'];

// Here are bunch of Propositions. They're not too useful by themselves, but they
// are the building blocks of Rules, so you'll need 'em in a bit.

$a-&gt;greaterThan($b);          // true if $a &gt; $b
$a-&gt;greaterThanOrEqualTo($b); // true if $a &gt;= $b
$a-&gt;lessThan($b);             // true if $a &lt; $b
$a-&gt;lessThanOrEqualTo($b);    // true if $a &lt;= $b
$a-&gt;equalTo($b);              // true if $a == $b
$a-&gt;notEqualTo($b);           // true if $a != $b
</code></pre>

<p>You can combine things to create more complex rules:</p>

<pre><code>// Create a Rule with an $a == $b condition
$aEqualsB = $rb-&gt;create($a-&gt;equalTo($b));

// Create another Rule with an $a != $b condition
$aDoesNotEqualB = $rb-&gt;create($a-&gt;notEqualTo($b));

// Now combine them for a tautology!
// (Because Rules are also Propositions, they can be combined to make MEGARULES)
$eitherOne = $rb-&gt;create($rb-&gt;logicalOr($aEqualsB, $aDoesNotEqualB));

// Just to mix things up, we'll populate our evaluation context with completely
// random values...
$context = new Context(array(
    'a' =&gt; rand(),
    'b' =&gt; rand(),
));

// Hint: this is always true!
$eitherOne-&gt;evaluate($context);
</code></pre>

<p>More complex examples:</p>

<pre><code>$rb-&gt;logicalNot($aEqualsB);                  // The same as $aDoesNotEqualB :)
$rb-&gt;logicalAnd($aEqualsB, $aDoesNotEqualB); // True if both conditions are true
$rb-&gt;logicalOr($aEqualsB, $aDoesNotEqualB);  // True if either condition is true
$rb-&gt;logicalXor($aEqualsB, $aDoesNotEqualB); // True if only one condition is true
</code></pre>

<p><strong>Full Examples</strong></p>

<p>Check if user is logged in:</p>

<pre><code>$context = new Context(array('username', function() {
    return isset($_SESSION['username']) ? $_SESSION['username'] : null;
}));

$userIsLoggedIn = $rb-&gt;create($rb['username']-&gt;notEqualTo(null));

if ($userIsLoggedIn-&gt;evaluate($context)) {
    // Do something special for logged in users!
}
</code></pre>

<p>If a Rule has an action, you can execute() it directly and save yourself a couple of lines of code.</p>

<pre><code>$hiJustin = $rb-&gt;create(
    $rb['userName']-&gt;equalTo('bobthecow'),
    function() {
        echo "Hi, Justin!";
    }
);

$hiJustin-&gt;execute($context);  // "Hi, Justin!"
</code></pre>

<p><strong>What does <a href="https://opensky.com" target="_blank">OpenSky</a> use Ruler for?</strong></p>

<p><a href="https://opensky.com" target="_blank">OpenSky</a> makes heavy use of Ruler. Below is a list of some of the conditions we have available in our application:</p>

<ul><li><p>Joins OpenSky</p>

<ul><li>Is Facebook Connected</li>
<li>Number of friends is &gt;= n</li>
<li>Number of friends is &lt;= n</li>
<li>With certain origination parameters existing in URL</li>
</ul></li>
<li><p>Makes a Purchase</p>

<ul><li>Within x days of joining</li>
<li>Is first purchase</li>
<li>Order amount is &gt;= n</li>
</ul></li>
<li><p>Loves an offer</p>

<ul><li>Is first love of the day</li>
</ul></li>
<li><p>Visits OpenSky</p>

<ul><li>Is Facebook Connected</li>
<li>Number of friends is &gt;= n</li>
<li>Number of friends is &lt;= n</li>
<li>Users points are &gt;= n</li>
</ul></li>
</ul>

<p>These are just some of the conditions we have available. Our application is setup in a way that we can easily create new rules via a backend GUI. We can mix and match conditions and rewards. Some of the rewards we have available are:</p>

<ul><li>Issue n points</li>
<li>New member level</li>
<li>Credit</li>
<li>Free shipping</li>
</ul>

<p>The benefit of this abstract setup is it allows us to combine different conditions, tweak the parameters of the conditions and issue rewards depending on the outcome of the condition all without requiring code changes and a deploy. You can imagine our business and marketing teams love this because they can change things all day long and without having to bother the tech team.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Doctrine DBAL: PHP Database Abstraction Layer]]></title>
            <link href="https://jwage.com/posts/2012/09/07/doctrine-dbal-php-database-abstraction-layer"/>
            <updated>2012-09-07T00:00:00-04:00</updated>
            <id>https://jwage.com/posts/2012/09/07/doctrine-dbal-php-database-abstraction-layer</id>
            <content type="html"><![CDATA[<p>Most people think ORM when they hear the name <a href="http://doctrine-project.org" target="_blank">Doctrine</a>, but what most people don&rsquo;t know, or forget, is that Doctrine is built on top of a very powerful Database Abstraction Layer that has been under development for over a decade. It&rsquo;s history can be traced back to 1999 in a library named Metabase which was forked to create PEAR MDB, then MDB2, Zend_DB and finally Doctrine1. In Doctrine2 the DBAL was completely decoupled from the ORM, components re-written for PHP 5.3 and made a standalone library.</p>

<p><strong>What does it support?</strong></p>

<ul><li>Connection Abstraction</li>
<li>Platform Abstraction</li>
<li>Data Type Abstraction</li>
<li>SQL Query Builder</li>
<li>Transactions</li>
<li>Schema Manager</li>
<li>Schema Representation</li>
<li>Events</li>
<li>Prepared Statements</li>
<li>Sharding</li>
</ul>

<p>Much more&hellip;</p>

<p><strong>Creating a Connection</strong></p>

<p>Creating connections is easy. It can be done by using the <code>DriverManager</code>:</p>

<pre><code>&lt;?php
$config = new \Doctrine\DBAL\Configuration();
//..
$connectionParams = array(
    'dbname' =&gt; 'mydb',
    'user' =&gt; 'user',
    'password' =&gt; 'secret',
    'host' =&gt; 'localhost',
    'driver' =&gt; 'pdo_mysql',
);
$conn = DriverManager::getConnection($connectionParams, $config);
</code></pre>

<p>The <code>DriverManager</code> returns an instance of <code>Doctrine\DBAL\Connection</code> which is a wrapper around the underlying driver connection (which is often a PDO instance).</p>

<p>By default we offer built-in support for many popular relational databases supported by PHP, such as:</p>

<ul><li>pdo_mysql</li>
<li>pdo_sqlite</li>
<li>pdo_pgsql</li>
<li>pdo_oci</li>
<li>pdo_sqlsrv</li>
<li>oci8</li>
</ul>

<p>If you need to do something custom, don&rsquo;t worry everything is abstracted so you can write your own drivers to communicate with any relational database you want. For example, recently work has <a href="https://github.com/doctrine/dbal/pull/191" target="_blank">begun</a> on integrating <a href="http://www.akiban.com/" target="_blank">Akiban SQL Server</a> with Doctrine.</p>

<p><strong>How to work with your data</strong></p>

<p>The <code>Doctrine\DBAL\Connection</code> object provides a convenient interface for retrieving and manipulating your data. You will find it is familiar and resembles PDO.</p>

<pre><code>$sql = "SELECT * FROM articles";
$stmt = $conn-&gt;query($sql);

while ($row = $stmt-&gt;fetch()) {
    echo $row['headline'];
}
</code></pre>

<p>To send an update and return the affected rows you can do:</p>

<pre><code>$count = $conn-&gt;executeUpdate('UPDATE user SET username = ? WHERE id = ?', array('jwage', 1));
</code></pre>

<p>It also provide a convenient <code>insert()</code> and <code>update()</code> method to make inserting and updating data easier:</p>

<pre><code>$conn-&gt;insert('user', array('username' =&gt; 'jwage'));
// INSERT INTO user (username) VALUES (?) (jwage)

$conn-&gt;update('user', array('username' =&gt; 'jwage'), array('id' =&gt; 1));
// UPDATE user (username) VALUES (?) WHERE id = ? (jwage, 1)
</code></pre>

<p><strong>Fluent Query Builder Interface</strong></p>

<p>If you need a programatic way to build your SQL queries you can do so using the <code>QueryBuilder</code>. The <code>QueryBuilder</code> object has methods to add parts to a SQL statement. The API is roughly the same as that of the DQL Query Builder.</p>

<p>To create a new query builder you can do so from your connection:</p>

<pre><code>$qb = $conn-&gt;createQueryBuilder();
</code></pre>

<p>Now you can start to build your query:</p>

<pre><code>$qb
    -&gt;select('u')
    -&gt;from('users', 'u')
    -&gt;where($qb-&gt;expr()-&gt;eq('u.id', 1));
</code></pre>

<p>You can use named parameters:</p>

<pre><code>$qb = $conn-&gt;createQueryBuilder()
    -&gt;select('u')
    -&gt;from('users', 'u')
    -&gt;where('u.id = :user_id')
    -&gt;setParameter(':user_id', 1);
</code></pre>

<p>It can handle joins:</p>

<pre><code>$qb = $conn-&gt;createQueryBuilder()
    -&gt;select('u.id')
    -&gt;addSelect('p.id')
    -&gt;from('users', 'u')
    -&gt;leftJoin('u', 'phonenumbers', 'u.id = p.user_id');
</code></pre>

<p>Updates and deletes are no problem:</p>

<pre><code>$qb = $conn-&gt;createQueryBuilder()
    -&gt;update('users', 'u')
    -&gt;set('u.password', md5('password'))
    -&gt;where('u.id = ?');

$qb = $conn-&gt;createQueryBuilder()
    -&gt;delete('users', 'u')
    -&gt;where('u.id = :user_id');
    -&gt;setParameter(':user_id', 1);
</code></pre>

<p>If you want to inspect the SQL resulting from a <code>QueryBuilder</code>, that is no problem:</p>

<pre><code>$qb = $em-&gt;createQueryBuilder()
    -&gt;select('u')
    -&gt;from('User', 'u')
echo $qb-&gt;getSQL(); // SELECT u FROM User u
</code></pre>

<p>The interface has much more and handles most everything you can do when writing SQL manually. It instantly makes your queries reusable, extensible and easier to manage.</p>

<p><strong>Managing your Schema</strong></p>

<p>One of my favorite features of the Doctrine 2.x series is the schema management feature. A <code>SchemaManager</code> instance helps you with the abstraction of the generation of SQL assets such as Tables, Sequences, Foreign Keys and Indexes.</p>

<p>To get a <code>SchemaManager</code> you can use the <code>getSchemaManager()</code> method on your connection:</p>

<pre><code>$sm = $conn-&gt;getSchemaManager();
</code></pre>

<p>Now you can introspect your database with the API:</p>

<pre><code>$databases = $sm-&gt;listDatabases();
$sequences = $sm-&gt;listSequences('dbname');

foreach ($sequences as $sequence) {
    echo $sequence-&gt;getName() . "\n";
}
</code></pre>

<p>List the columns in a table:</p>

<pre><code>$columns = $sm-&gt;listTableColumns('user');
foreach ($columns as $column) {
    echo $column-&gt;getName() . ': ' . $column-&gt;getType() . "\n";
}
</code></pre>

<p>You can even issue DDL statements from the <code>SchemaManager</code>:</p>

<pre><code>$table-&gt;addColumn('email_address', 'string');
</code></pre>

<p><strong>Schema Representation</strong></p>

<p>For a complete representation of the current database you can use the createSchema() method which returns an instance of <code>Doctrine\DBAL\Schema\Schema</code>, which you can use in conjunction with the <code>SchemaTool</code> or <code>SchemaComparator</code>.</p>

<pre><code>$fromSchema = $sm-&gt;createSchema();

$toSchema = clone $fromSchema;
$toSchema-&gt;dropTable('user');
$sql = $fromSchema-&gt;getMigrateToSql($toSchema, $conn-&gt;getDatabasePlatform());

print_r($sql);

/*
array(
  0 =&gt; 'DROP TABLE user'
)
*/
</code></pre>

<p>The <code>SchemaManager</code> allows for some nice functionality to be built for the <a href="http://www.doctrine-project.org/projects/orm.html" target="_blank">Doctrine ORM</a> project for reverse engineering databases in to Doctrine mapping files. This makes it easy to get started using the ORM with legacy databases. It is also used in the <a href="http://www.doctrine-project.org/projects/migrations.html" target="_blank">Doctrine Migrations</a> project to allow you to manage versions of your schema and easily deploy changes to production databases in a controlled and versioned fashion.</p>

<p>The next time you need to access a relational database in PHP, whether it be in a proprietary or open source application, consider <a href="http://doctrine-project.org" target="_blank">Doctrine</a>. Take advantage of our community and team of developers so you can focus on your core competency and really excel in it.</p>
]]></content>
        </entry>
    </feed>